# 프론트엔드 개발 환경의 이해와 학습

# 프론트엔드 개발에 Node.js가 필요한 이유

### 최신 스펙으로 개발 할 수 있다.

webpack, babel, npm 등은 노드 위에서 돌아간다.

Typescript, SASS 같은 고수준 프로그래밍 언어도 전용 트랜스파일러가 필요한데 이것 역시 Node.js 환경이 뒷받침 되어야만 프론트엔드 개발 환경을 만들 수 있다.

### 빌드 자동화

파일을 압축, 코딩을 난독화 하고, 브라우저에 따라 폴리필을 추가하는 등 개발 이외에 후속 작업을 거친 후 배포를 하게 된다. Node.js는 이런 일련의 빌드 과정을 이해하는데 큰 역할을 한다. 뿐만 아니라 라이브러리 의존성을 해결하고 각종 테스트를 자동화 하는데도 사용한다.

### 개발 환경 커스터마이징

vue-cli나 CRA(create react app)등을 사용할 수 없는 경우도 빈번하다. 커스터마이징 하려먼 Node.js 지식이 필요하다. 

# Node.js 설치

- LTS 버전과 최신 버전을 제공하는데 node를 서버로 구성하는 경우는 신중 해야겠지만 개발 환경의 경우 최신 버전을 써 보자.
- REPL (read-eval-print loop)
- node를 설치하면 npm도 설치 된다.
- `npm init` 프로젝트를 생성하는 명령어로 프로젝트의 메타 정보를 입력할 수 있다.
- 터미널에서 npm 을 입력하면 사용 가능한 npm 커맨드들을 확인 할 수 있다. 기본적으로 제공하는 커맨드 외에 커맨드를 추가하고 싶다면  package.json에 추가하면 된다. 커스텀 커맨드를 실행할 때는 `npm run 커맨드 이름]` 을 입력하면 된다.

# 외부 패키지를 관리하는 방법

### 1. CDN(contents delivery network)

보통 JS 라이브러리, CSS 라이브러리를 빠르게 제공해주는 서버이다. 

(예) react cdn

    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>

하지만 CDN 서버 장애로 인해 외부 라이브러리를 사용할 수 없다면 우리가 만드는 어플리케이션도 정상적으로 동작하지 않을 것이다.

### 2. 직접 다운로드 하는 방법

CDN과 달리 독립적으로 웹 어플리케이션을 제공할 수 있다.

하지만 라이브러리는 계속 업데이트 될 것이고 우리가 만드는 프로젝트에서도 최신 버전으로 매번 교체해야 한다. 이것은 매우 귀찮은 일이고 호환성 확인까지 하려면 실수 할 여지가 많다.

### 3. NPM을 이용하는 방법

node.js 가 패지키 버전을 관리하는 방식

프로젝트에서 사용하는 패키지의 버전을 매우 엄격하게 제한한다면 프로젝트를 버전업 하는데 꽤 힘들 수 있다. 사용하는 패키지를 전부 버전업 해야 하기 때문이다.

반대로 느슨하게 풀어놓으면 문제가 해결될까? 오히려 여러 버전 별로 코드를 관리해야 하는 혼란스러움을 겪게 될 것이다.

**유의적 버전** (Sementic Version)

- Major Version - 기존 버전과 호환 되지 않게 변경한 경우
- Minor Version - 기존 버전과 호환 되면서 기능이 추가 된 경우
- Patch Version - 기존 버전과 호환 되면서 버그를 수정한 경우

Node.js는 유의적 버전의 규칙을 따른다.

    //특정 버전 사용
    1.2.3
    
    //특정 버전보다 높거나 낮을 경우
    >1.2.3
    >=1.2.3
    <1.2.3
    <=1.2.3
    
    //~(틸트) 마이너 버전이 명시되어 있으면 패치 버전을 변경한다.
    ~1.2.3 //1.2.3부터 1.3.0 미만까지를 포함한다. 
    ~0 //마이너 버전이 없으면 마이너 버전을 갱신한다. 0.0.0부터 1.0.0까지를 포함한다.
    
    //^(캐럿) 정식 버전에서 마이너와 패치버전을 변경한다.
    ^1.2.3 //1.2.3부터 2.0.0 미만까지를 포함한다. 
    ^0 //정식버전 미만인  0.x버전은 패치만 갱신한다. 0.0.0부터 0.1.0 미만까지를 포함한다.
    

npm으로 패키지를 설치하면 package.json에 설치한 버전을 기록하는데 캐럿 방식을 이용한다. 초기에는 틸트를 사용하다가 캐럿을 도입해서 기본 동작으로 사용했다. 

# 웹팩이 필요한 이유와 기본 동작

### 배경 - 모듈

JS에서 문법 수준의 모듈을 지원하기 시작한 것은 ES2015부터다. import/export 구문이 없었던 모듈 이전 상황을 살펴 보는 것이 웹팩 등장 배경을 이해하는데 수월 하다.

과거에는 하나의 html 파일에 여러 개의 js를 올리고 다른 파일에 있는 함수를 호출해서 사용을 했었다. 하지만 그렇게 되면 전역 스코프가 오염이 된다. 하나의 파일에 있는 함수는 해당 파일 안에서만 유효한 것이 아니라 어플리케이션의 전역(window)에 등록되기 때문이다. (window) 전역 스코프가 오염되면 예측할 수 없는 어플리케이션이 되어 런타임 에러가 발생한다.

**IIFE**

이런 문제를 해결하기 위해서 IIFE (Immediately Invoked function express) 방식의 모듈을 사용한다. 즉시 함수 실행은 함수 안에 독립적인 스코프가 생기기 때문에 함수 내부에서 정의한 것은 함수 외부에서 접근 할 수 없기 때문에 전역 스코프가 오염되는 것을 예방할 수 있다.

이러한 방식으로 JS 모듈을 구현하는 대표적인 명세가 AMD와 CommonJS 다. 

**CommonJS**

CommonJS는 JS를 사용하는 모든 환경에서 모듈을 사용하는 것이 목표다. exports 키워드로 모듈을 만들고 require() 함수로 불러 들이는 방식이다. 대표적으로 Node.js에서 사용한다.

    exports function sum (a, b) {
    	return a + b
    }

    const sum = require('./math.js');
    sum(1, 2); //3

브라우저처럼 외부에서 자바스크립트를 로딩 해야 하는 비동기 환경에서는 AMD(Asynchronous Module Definition) 를 사용한다.

CommonJS와 AMD를 통합해서 지원하는 것이 UMD(Universal Module Definition) 이다.

이렇게 각 커뮤니티에서 각자 스펙을 제안하다가 ES2015에서 표준 모듈 시스템을 내놓았다. 지금은 바벨과 웹팩을 이용해서 이 표준 모듈 시스템을 사용하는 것이 일반적이다. 

    export function sum (a, b) {
    	return a + b;
    }

    import * as math from './math.js';
    
    math.sum(1, 2); //3

### 브라우저의 모듈 지원

모든 브라우저들이 모듈을 지원 하는 것은 아니다. IE를 비롯한 몇 몇 브라우저에서는 여전히 모듈을 사용하지 못한다. 크롬은 버전 61부터 모듈 시스템을 지원한다.

 [크롬] 크롬에서는 script 태그를 로딩할 때 `type="text/javascript"` 대신 `type="module"` 을 사용한다. 

    <script type="module" src="app.js"></script>

모든 브라우저에서 무관하게 모듈을 사용하고 싶다면 이제야 웹팩이 나올 차례이다.

# mode/entry/output(path, filename)

번들 작업을 하는 webpack 패키지와 웹팩을 터미널 명령으로 사용할 수 있는 webpack-cli를 설치하자.

    npm install -d webpack webpack-cli

`node_module/.bin/webpack --help` 로 일단 한번 살펴보자.

웹팩을 실행 할 때는 필수적인 옵션이 3개가 있다.

- `--mode` : development, production, none
- `--entry` : 모듈의 시작점
- `--output` : entry 를 통해서 번들링을 하고 그 결과를 저장하는 경로를 설정하는 옵션이다.

이 외에도 많은 옵션이 있다. 매번 명령어를 입력 할 때마다 옵션을 타이핑 할 수 없으니 웹팩 설정 파일을 만들어 보자.

- `--config` : 웹팩 설정 파일을 지정 할 수 있다. 기본은 파일명은 webpack.config.js 또는 webpackfile.js 다.

webpack.config.js

    const path = require('path');
    
    //여기서 module.exports는 ES6 모듈이 아니라 node의 모듈이다.
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            //out diretory 명으로 절대 경로로 입력한다.
            path: path.resolve('./dist'),
            //name은 entry의 main으로 치환된다. 이렇게 하면 output이름을 동적으로 만들어 낼 수 있는 효과가 있다.
            filename: '[name].js'
        }
    }

npm 은 프로젝트를 관리하는 도구이다. 특히 스크립트를 자동화 하는 기능이 있다. 

package.json

    {
      "name": "lecture-frontend-development-environment",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build" : "webpack" //이렇게만 해도 기본 config 파일인 webpack.config.js 파일을 읽어서 번들링 한다
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "webpack": "^4.42.0",
        "webpack-cli": "^3.3.11"
      }
    }

# 로더

웹팩은 모든 파일을 모듈로 바라본다. JS 모듈 뿐 아니라 CSS, 이미지, 폰트 까지 모두 모듈로 보기 때문에 ES6의 import 키워드를 사용하면 자바스크립트 코드 안으로 가져올 수 있다.

이것이 가능한 이유는 웹팩에 로더가 있기 때문이다.

웹팩에서 로더의 역할을 모든 파일을 자바스크립트의 모듈처럼 만들어 주는 것이다. 

### 커스텀 로더 만들어 보기

 my-webpack-loader.js

    //로더는 함수 형태로 작성한다.
    module.exports = function myWebpackLoader (content) {
        console.log('myWebpackLoader works');
        return content;
    }

이렇게 만든 로더를 사용해 하려면 webpack.config.js 파일로 가보자.

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
    		//로더는 모듈 객체의 rules라는 배열에 추가 할 수 있다.
        module : {
            rules : [
                {
                    test : /\.js$/, //로더가 처리해야 할 파일들의 패턴을 입력한다. 여기서는 모든 JS 파일.
                    use: [
                        path.resolve('./my-webpack-loader.js')
                    ]
                }
            ]
        }
    }

정리 하면 웹팩의 로더는 각 파일을 처리하기 위한 것이다. 처리 할 파일의 패턴을 명시하고 패턴에 해당 하는 파일들을 로더 함수를 이용해 처리한다.

# 자주 사용하는 로더

### css-loader

css에 로더를 설정하게 되면 자바스크립트에서 css파일을 모듈로 불러 올 수 있다.

    npm install -d css-loader

    import './app.css'

    body {
    	background-color: green;
    }

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
    		//로더는 모듈 객체의 rules라는 배열에 추가 할 수 있다.
        module : {
            rules : [
                {
                    test : /\.css$/,
                    use: [
                        'css-loader'
                    ]
                }
            ]
        }
    }

HTML이 코드가 DOM이라는 모습으로 변환 되어야 브라우저에서 문서가 보이듯이 CSS 코드도 CSS OM이라는 형태로 바뀌어야만 브라우저에서 모습을 드러낸다.

그렇게 하려면 css 코드를 직접 불러오거나 인라인 script로 넣어 줘야 한다. 위에서는 아직 그러한 처리를 하지 않고 자바스크립트 파일에만 css 코드가 있어서 브라우저에 반영되지 않는 것이다.

그래서 나온 것이 style-loader이다. 자바스크립트로 변경 된 스타일 코드를 HTML에 넣어주는 역할을 한다. 

 CSS 코드를 모듈로 사용하고 번들을 하려면 css-loader와 style-loader를 같이 사용해야 한다.

### style-loader

    npm instll -d style-loader

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
    		//로더는 모듈 객체의 rules라는 배열에 추가 할 수 있다.
        module : {
            rules : [
                {
                    test : /\.css$/, //로더가 처리해야 할 파일들의 패턴을 입력한다. 여기서는 모든 JS 파일.
                    use: [
                        'style-loader',
                        'css-loader'
                    ]
                }
            ]
        }
    }

번들링 후 html을 확인 하면 아래처럼 head에 style 태그가 들어가 있다.

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    		<style>body {
    		    background-color: green;
    		}</style>
    </head>

### file-loader

CSS 뿐만 아니라 이미지 파일도 처리할 수 있다.

    npm install -d file-loader

    body {
        background-image: url(bg.png)
    }

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
    		//로더는 모듈 객체의 rules라는 배열에 추가 할 수 있다.
        module : {
            rules : [
                {
                    test: /\.css$/, 
                    use: [
                        'style-loader',
                        'css-loader'
                    ]
                }, {
                    test: /\.png$/,
                    use: [
                        'file-loader'
                    ]
                }
            ]
        }
    }

웹팩은 빌드를 할 때마다 유니크한 값(해시)을 생성하는데, 이것으로 파일명이 바뀐다. 캐시 갱신을 위해서다. 정적 파일의 경우 브라우저에서 캐시하는 경우가 하나인데, 성능 개선을 위해서다. 파일 내용이 달라 지고 이름이 같으면, 이전의 캐시로 저장했던 파일 내용을 브라우저가 사용하는데 이런 것을 예방하는 방법 중 하나가 파일 이름을 변경 하는 것이다.

webpack.config.js 파일을 아래처럼 수정해 보자.

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
    		//로더는 모듈 객체의 rules라는 배열에 추가 할 수 있다.
        module : {
            rules : [
                {
                    test: /\.css$/, //로더가 처리해야 할 파일들의 패턴을 입력한다. 여기서는 모든 JS 파일.
                    use: [
                        'style-loader',
                        'css-loader'
                    ]
                }, {
                    test: /\.png$/,
                    loader: 'file-loader',
                    options: {
                        //파일 로더가 사용하는 파일을 모듈로 사용 했을 때, 경로 앞에 추가되는 문자열이다. 
                        publicPath: './dist',
                        //파일 로더가 파일을 아웃풋에 복사할 때 사용하는 파일 이름이다. 원본파일.확장자?해시 (캐시 무력화를 위해서 해시를 쿼리스크링으로 사용한다.)
                        name: '[name].[ext]?[hash]'
                    }
                }
            ]
        }
    }

### url-loader

사용하는 이미지 갯수가 많아지면 네트워크 리소스를 사용하는 부담이 있고 사이트 성능에 영향을 줄 수도 있다. 만약 한 페이지 안에서 작은 이미지 여러 개를 사용한다면 Data URI Schema를 이용하는 방법이 더 낫다. 

**Data URI Schema**

    <img src="data:image/png;base64,iVBORw0KGgoAAA
    ANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4
    //8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU
    5ErkJggg==" alt="Red dot" />

이렇게 하면 네트워크 통신 없이 화면을 그려 준다.

url-loader는 이러한 처리를 자동화 해주는 기능을 한다.

    npm install -d url-loader

    import './app.css'
    import nyancat from './nyancat.jpg'
    
    document.addEventListener('DOMContentLoaded', () => {
        document.body.innerHTML = `
            <img src="${nayncat} />
        `
    })

    const path = require('path');
    
    module.exports = {
        mode: 'development',
        entry: {
            main: './src/app.js'
        },
        output: {
            path: path.resolve('./dist'),
            filename: '[name].js'
        },
        module : {
            rules : [
                {
                    test: /\.css$/, 
                    use: [
                        'style-loader',
                        'css-loader'
                    ]
                }, {
                    test: /\.(png|jpg|gif|svg)$/,
                    loader: 'file-loader',
                    options: {
                        publicPath: './dist',
                        name: '[name].[ext]?[hash]'
                    }
                }
            ]
        }
    }